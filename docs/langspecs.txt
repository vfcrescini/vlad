-------------------------------------------------------------------------------
VLAD: V Logic-based Access-control Database
Language Specifications

Vino Crescini  <jcrescin@cit.uws.edu.au>
-------------------------------------------------------------------------------
Started 2002 Dec 8
-------------------------------------------------------------------------------

1. Expressions

  1.1. Identifiers

    Identifiers are case-sensitive, alpha-numeric characters. The first
    character of an identifier must be an alpha character followed by
    zero to 127 characters of alpha, digit or underscore characters. 
    Identifiers may be used to identify subject, access-right and object
    entities or groups, transformations or variables.

      [a-zA-Z][a-zA-Z0-9_]{0,127}

    See Definition section for information on how to delcare identifiers.

  1.2. Atoms

    1.2.1. Relational Atoms

      A single logical fact stating a relation between a subject and an object.
      There is no distinction between singular entities and group entities.

        holds(subject, access_right, object)

    1.2.2. Subset Atoms

      A single logical fact describing a set containment relationship to
      another set.

        subst(Subject_1, Subject_2) 

      is read as

        "group Subject_1 is contained in group Subject_2"

      or

        "group Subject_1 is a subset of group Subject_2"

    1.2.3. Membership Atoms

      A single logical fact describing the membership of a singular 
      subject/access-right/object to a subject/access-right/object group.

        memb(subject_1, Subject_1)

      is read as

        "subject_1 is an element of group Subject_1"

  1.3. Compound Statements

    1.3.1. Conjuction

      Atoms can be grouped together with the logical conjunction AND. Note that
      DISJUNCTIONS are NOT allowed in this language. The symbol for this
      conjuction is && (double ampersand, as it is in C).

        <atom> && <atom> && ...

    1.3.2. Negation

      Atoms can be negated with the ! symbol (exclamation-point, as it is
      in C).
     
        ! <atom>

    1.3.3. Operator Precedence

      The negation operator has higher precedence than the conjunction
      operator.

        ! holds(sub1, acc1, obj1) && ! holds(sub2, acc2, obj2)

      is evaluated as

        (! holds(sub1, acc1, obj1)) && (! holds(sub2, acc2, obj2))

      Compound statements are always evaluated from left to right. This means
      the left-most operator (conjuction or negation) is evaluated first. This
      can be safely ignored since the language contains only 2 operators with 
      different precedence levels.

        ! holds(sub1, acc1, obj1) && 
        holds(sub2, acc2, obj2) && 
        holds(sub3, acc3, obj3)

      is evaluated as

        ((! holds(sub1, acc1, obj1)) && 
        holds(sub2, acc2, obj2)) &&
        holds(sub3, acc3, obj3)

    1.3.4. Parentheses

      Parenthesis is not allowed to be used to enclose atoms and expressions.

  1.4. Constant Expressions

    The following symbols may be used:

      true

      false

  1.5. Variables

   Variables are only permitted to occur on transformation proposition
   statements. They must be in the form:

     [a-zA-Z][a-zA-Z0-9]*

2. Definition Statements

  2.1 Identifier Definition Statements

    All identifiers, except transformation and variable identifiers, must be
    declared first before any proposition and query statements are declared.
    The following syntax must be used to declare identifiers.

      ident <type> <identifier>[,<identifier2>[,...]]

      where:

        type is one of the following: sub, acc, obj, sub-grp, acc-grp, obj-grp
        identifier is [a-zA-Z][a-zA-Z0-9_]{0,127} and is not a reserved word.

  2.2. Initial State Defintion

    The initial state can be defined by the following statement

      initially <expression>

    Note that <expression> may be a conjuction of many atoms. Also, the
    initially clause may be used more than once.

  2.3. Transformation Definition Statement

    A transformation definition statement must be defined in the following
    syntax:

      trans <trans-identifier>([<var1>[,<var2>][,...]]])
      causes <post-condition-expression>
      if <pre-condition-expression>

    where:

      <trans-identifier> is the identifier of this transformation. Must
        start with a t or a T.

      <post-condition-expression> an expression that will be true in the
        resulting state after the transformation is the identifier of this
        transformation.

      <pre-condition-expression> an expression that must be true in the
        current state before the transformation may be applied.

    Note that a transformation definition statement may have variables:

      trans tdelete-write(vSUBJECT, vOBJECT)
      causes !holds(vSUBJECT, a_write, vOBJECT)
      if holds(vSUBJECT, a_write, vOBJECT)

    this means 

      tdelete-write(subject1, object1)

    and

      tdelete-write(subject2, object2)

    will cause

      !holds(subject1, a_write, object1)

    and

      !holds(subject2, a_write, object2)

    if subject1 and subject2 had write access rights to object1 and object2,
    respectively.

    The case where the pre-condition is an empty-set (ie. the transformation
    has no pre-condition) does not have to be a special case:

      trans <trans-identifier>()
      causes <post-condition-expression> 
      if true

    The constant expression "true" can be used to indicate that there are no
    pre-conditions required for this transformation.

  2.4. Policy Proposition Definition Statement

    This statement is used for queries.

      is <policy-expression> 
      after <trans-identifier-1>, <trans-identifier-2>, ...

    Or, to query the initial state:

      is <policy-expression> 

    The statement will return one of the following: true, false or ?


  2.5. Constraint Definition Statement

    In addition to the initial statement definitions, it is also possible
    to define constraints (or default proposition) in the knowledge base.

    Constraint expressions are true in the intial state and remain true
    after any transformation.

    The most general form:

      <expression1> implies <expression2> with absence <expression3>

    states that expression2 holds if expression1 is true and the truth 
    value of expression3 is unknown. Obviously, if expression3 is the 
    constant "true" or "false" then the constraint will not be applied, 
    regardless of the truth-value of exression1.

    If the "with absence" clause is ommitted, then expression2 is applied
    if and only if expression1 is true:

      <expression1> implies <expression2>

    A special case of the above is when expression1 is the constant "true".
    In this case, expression2 is always applied. The statement below:

      always <expression2>

    is equivalent to

      true implies <expression2>

3. Comments

  C-style comments may appear anywhere in the file. Any characters
  between "/*" and "*/" will be ignored by the parser.
