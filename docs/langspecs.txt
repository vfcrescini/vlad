-------------------------------------------------------------------------------
VLAD: V Logic-based Access-control Database
Language Specifications

Vino Fernando Crescini  <jcrescin@cit.uws.edu.au>
-------------------------------------------------------------------------------
Started 2002 Dec 08
-------------------------------------------------------------------------------

1. Expressions

  1.1. Identifiers

    Identifiers are case-sensitive, alpha-numeric characters. The first
    character of an identifier must be an alpha character followed by
    zero to 127 characters of alpha, digit or underscore characters.
    Identifiers may be used to identify subject, access-right and object
    entities or groups, transformations or variables.

      [a-zA-Z][a-zA-Z0-9_]{0,127}

    See Definition section for information on how to delcare identifiers.

  1.2. Atoms

    1.2.1. Relational Atoms

      A single logical fact stating a relation between a subject and an object.
      There is no distinction between singular entities and group entities.

        holds(subject, access_right, object)

    1.2.2. Subset Atoms

      A single logical fact describing a set containment relationship to
      another set.

        subst(Subject_1, Subject_2)

      is read as

        "group Subject_1 is contained in group Subject_2"

      or

        "group Subject_1 is a subset of group Subject_2"

    1.2.3. Membership Atoms

      A single logical fact describing the membership of a singular
      subject/access-right/object to a subject/access-right/object group.

        memb(subject_1, Subject_1)

      is read as

        "subject_1 is an element of group Subject_1"

  1.3. Compound Statements

    1.3.1. Conjuction

      Atoms can be grouped together with the logical conjunction AND. Note that
      DISJUNCTIONS are NOT allowed in this language. The symbol for this
      conjuction is && (double ampersand, as it is in C).

        <atom> && <atom> && ...

    1.3.2. Negation

      Atoms can be negated with the ! symbol (exclamation-point, as it is
      in C).

        ! <atom>

    1.3.3. Operator Precedence

      The negation operator has higher precedence than the conjunction
      operator.

        ! holds(sub1, acc1, obj1) && ! holds(sub2, acc2, obj2)

      is evaluated as

        (! holds(sub1, acc1, obj1)) && (! holds(sub2, acc2, obj2))

      Compound statements are always evaluated from left to right. This means
      the left-most operator (conjuction or negation) is evaluated first. This
      can be safely ignored since the language contains only 2 operators with
      different precedence levels.

        ! holds(sub1, acc1, obj1) &&
        holds(sub2, acc2, obj2) &&
        holds(sub3, acc3, obj3)

      is evaluated as

        ((! holds(sub1, acc1, obj1)) &&
        holds(sub2, acc2, obj2)) &&
        holds(sub3, acc3, obj3)

    1.3.4. Parentheses

      Parenthesis is not allowed to be used to enclose atoms and expressions.

  1.4. Variables

   Variables are only permitted to occur on transformation proposition
   statements. They must be in the form:

     [a-zA-Z][a-zA-Z0-9]*

2. Program Definition Statements

  2.1 Identifier Definition Statements

    All identifiers, except transformation and variable identifiers, must be
    declared first before any proposition and query statements are declared.
    The following syntax must be used to declare identifiers.

      ident <type> <identifier>[,<identifier2>[,...]]

      where:

        type is one of the following: sub, acc, obj, sub-grp, acc-grp, obj-grp
        identifier is [a-zA-Z][a-zA-Z0-9_]{0,127} and is not a reserved word.

  2.2. Initial State Defintion

    The initial state can be defined by the following statement

      initially <expression>

    Note that <expression> may be a conjuction of many atoms. Also, the
    initially clause may be used more than once.

  2.3. Transformation Definition Statement

    A transformation definition statement must be defined in the following
    syntax:

      <trans-identifier>([<var1>[,<var2>][,...]]])
      causes <post-condition-expression>
      [if <pre-condition-expression>]

    where:

      <trans-identifier> is the identifier of this transformation.

      <post-condition-expression> an expression that will be true in the
        resulting state after the transformation is applied.

      <pre-condition-expression> an expression that must be true in the
        current state before the transformation may be applied.

    Note that a transformation definition statement may have variables:

      delete_write(vSUBJECT, vOBJECT)
      causes !holds(vSUBJECT, a_write, vOBJECT)
      if holds(vSUBJECT, a_write, vOBJECT)

    this means

      delete_write(subject1, object1)

    and

      delete_write(subject2, object2)

    will cause

      !holds(subject1, a_write, object1)

    and

      !holds(subject2, a_write, object2)

    if subject1 and subject2 had write access rights to object1 and object2,
    respectively.

    The case where the pre-condition is an empty-set (ie. the transformation
    has no pre-condition) is represented by omitting the if clause:

      <trans-identifier>()
      causes <post-condition-expression>

  2.4. Constraint Definition Statement

    In addition to the initial statement definitions, it is also possible
    to define constraints (or default proposition) in the knowledge base.

    Constraint expressions are true in the intial state and remain true
    after any transformation.

    The most general form:

      always <expression1> implied by <expression2> with absence <expression3>

    states that expression1 holds if expression2 is true and the truth
    value of expression3 is unknown.

    If the "with absence" clause is omitted, then expression1 is applied
    if and only if expression2 is true:

      always <expression1> implied by <expression2>

    Likewise, if the "implied by" clause is omitted, then expression1 holds
    if there is no evidence that expression3 is true:

      always <expression1> with absence <expression3>

    Finally, if both conditions are omitted, then expression1 will always hold:

      always <expression1>

3. Operations Statements

  3.1. Query Statement

    This statement is used to evaluate queries from the current state. The
    current state will then be derived from the initial state after all
    transformations in the sequence (see below) has been applied.

      query <expression>

    The statement will return one of the following: true, false or ?

  3.2. Compute Statement

    This statement is used to signal the parser to prepare the knowledge
    base for queries. It is important that this statement is declared between
    any number of sequence manipulation statements and query statements.

  3.3. Transformation Sequence Manipulations

    3.3.1. Add

      This statement is used to append a transformation reference at the end of
      the transformation sequence list. A transformation reference must, of
      course, be a valid transformation defined in the transformation
      definition section.

        seq add <trans-ident>([arg1][,arg2][,...]);

    3.3.2. List

      This statement will trigger the output of the transformation sequence
      list.

        seq list;

      Output format is:

        <index1> <trans-ident1>([arg1][,arg2][,...]);
        <index2> <trans-ident2>([arg1][,arg2][,...]);
        ...

      Where <indexn> is the ordinal index (starting from 0) of a transformation
      as it appears in the sequence.

    3.3.3. Delete

      To remove a transformation from the transformation sequence:

        seq del <index>;

      Where <index> is the ordinal index of the corresponding transformation
      as listed by the "seq list" statement.

4. Comments

  C-style comments may appear anywhere in the file. Any characters
  between "/*" and "*/" will be ignored by the parser.

5. Reserved Words

  The following is a list of words that cannot be used as an identifier:

    - holds
    - memb
    - subst
    - initially
    - implied
    - by
    - with
    - absence
    - always
    - causes
    - if
    - ident
    - sub-grp
    - obj-grp
    - acc-grp
    - sub
    - obj
    - acc
    - query
    - compute
    - seq
    - add
    - del
    - list
